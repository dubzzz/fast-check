import { Random } from '../../random/generator/Random';
import { Stream } from '../../stream/Stream';
import { cloneMethod } from '../symbols';
import { Arbitrary } from './definition/Arbitrary';
import { convertFromNext, convertToNext } from './definition/Converters';
import { NextArbitrary } from './definition/NextArbitrary';
import { NextValue } from './definition/NextValue';

/** @internal */
class CloneArbitrary<T> extends NextArbitrary<T[]> {
  constructor(readonly arb: NextArbitrary<T>, readonly numValues: number) {
    super();
  }

  generate(mrng: Random, biasFactor: number | undefined): NextValue<T[]> {
    const items: NextValue<T>[] = [];
    if (this.numValues <= 0) {
      return this.wrapper(items);
    }
    // We call generate multiple times to have fully independent values
    for (let idx = 0; idx !== this.numValues - 1; ++idx) {
      items.push(this.arb.generate(mrng.clone(), biasFactor));
    }
    items.push(this.arb.generate(mrng, biasFactor));
    return this.wrapper(items);
  }

  canGenerate(value: unknown): value is T[] {
    if (!Array.isArray(value) || value.length !== this.numValues) {
      return false;
    }
    const numDistinctValues = new Set(value).size;
    if (numDistinctValues <= 1) {
      // 0 and 1 are valid
      return true;
    }
    // We don't relally know:
    // >  Properly implementing canGenerate for general case is really complex.
    // >  If values generated by `this.arb` cannot be compared using `Object.is` then the check is impossible.
    return false;
  }

  shrink(value: T[], context?: unknown): Stream<NextValue<T[]>> {
    return new Stream(this.shrinkImpl(value, context !== undefined ? (context as unknown[]) : [])).map((v) =>
      this.wrapper(v)
    );
  }

  private *shrinkImpl(value: T[], contexts: unknown[]): IterableIterator<NextValue<T>[]> {
    const its = value.map((v, idx) => this.arb.shrink(v, contexts[idx])[Symbol.iterator]());
    let cur = its.map((it) => it.next());
    while (!cur[0].done) {
      yield cur.map((c) => c.value);
      cur = its.map((it) => it.next());
    }
  }

  private static makeItCloneable<T>(vs: T[], shrinkables: NextValue<T>[]) {
    (vs as any)[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        cloned.push(shrinkables[idx].value); // push potentially cloned values
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }

  private wrapper(items: NextValue<T>[]): NextValue<T[]> {
    let cloneable = false;
    const vs: T[] = [];
    const contexts: unknown[] = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      vs.push(s.value);
      contexts.push(s.context);
    }
    if (cloneable) {
      CloneArbitrary.makeItCloneable(vs, items);
    }
    return new NextValue(vs, contexts);
  }
}

/**
 * Type of the value produced by {@link clone}
 * @remarks Since 2.5.0
 * @public
 */
export type CloneValue<T, N extends number> = N extends 0
  ? []
  : N extends 1
  ? [T]
  : N extends 2
  ? [T, T]
  : N extends 3
  ? [T, T, T]
  : N extends 4
  ? [T, T, T, T]
  : T[];

/**
 * Clone the values generated by `arb` in order to produce fully equal values (might not be equal in terms of === or ==)
 *
 * @param arb - Source arbitrary
 * @param numValues - Number of values to produce
 *
 * @remarks Since 2.5.0
 * @public
 */
function clone<T, N extends number>(arb: Arbitrary<T>, numValues: N): Arbitrary<CloneValue<T, N>>;
function clone<T>(arb: Arbitrary<T>, numValues: number): Arbitrary<T[]> {
  return convertFromNext(new CloneArbitrary(convertToNext(arb), numValues));
}
export { clone };

import Random from '../../random/generator/Random';
import Arbitrary from './definition/Arbitrary';
import Shrinkable from './definition/Shrinkable';

export interface WeightedArbitrary<T> {
  weight: number;
  arbitrary: Arbitrary<T>;
}

/** @hidden */
class FrequencyArbitrary<T> extends Arbitrary<T> {
  readonly summedWarbs: WeightedArbitrary<T>[];
  readonly totalWeight: number;
  constructor(readonly warbs: WeightedArbitrary<T>[]) {
    super();
    this.summedWarbs = warbs
      .reduce(
        (p: WeightedArbitrary<T>[], c) =>
          p.concat({
            weight: p[p.length - 1].weight + c.weight,
            arbitrary: c.arbitrary
          }),
        [{ weight: 0, arbitrary: warbs[0].arbitrary }]
      )
      .slice(1);
    this.totalWeight = this.summedWarbs[this.summedWarbs.length - 1].weight;
  }
  generate(mrng: Random): Shrinkable<T> {
    const selected = mrng.nextInt(0, this.totalWeight - 1);
    return this.summedWarbs.find(warb => selected < warb.weight)!.arbitrary.generate(mrng);
  }
  withBias(freq: number) {
    return new FrequencyArbitrary(this.warbs.map(v => ({ weight: v.weight, arbitrary: v.arbitrary.withBias(freq) })));
  }
}

/**
 * For one of the values generated by `...warbs` - the probability of selecting the ith warb is of `warb[i].weight / sum(warb[j].weight)`
 *
 * **WARNING**: It expects at least one (Arbitrary, weight)
 *
 * @param warbs (Arbitrary, weight)s that might be called to produce a value
 */
function frequency<T>(...warbs: WeightedArbitrary<T>[]): Arbitrary<T> {
  if (warbs.length === 0) {
    throw new Error('fc.frequency expects at least one parameter');
  }
  return new FrequencyArbitrary([...warbs]);
}

export { frequency };

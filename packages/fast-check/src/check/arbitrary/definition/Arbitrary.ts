import type { Random } from '../../../random/generator/Random';
import { Stream } from '../../../stream/Stream';
import { cloneMethod, hasCloneMethod } from '../../symbols';
import { Value } from './Value';

const safeObjectAssign = Object.assign;

/**
 * Abstract class able to generate values on type `T`
 *
 * The values generated by an instance of Arbitrary can be previewed - with {@link sample} - or classified - with {@link statistics}.
 *
 * @remarks Since 0.0.7
 * @public
 */
export abstract class Arbitrary<T> {
  /**
   * Generate a value of type `T` along with its context (if any)
   * based on the provided random number generator
   *
   * @param mrng - Random number generator
   * @param biasFactor - If taken into account 1 value over biasFactor must be biased. Either integer value greater or equal to 2 (bias) or undefined (no bias)
   * @returns Random value of type `T` and its context
   *
   * @remarks Since 0.0.1 (return type changed in 3.0.0)
   */
  abstract generate(mrng: Random, biasFactor: number | undefined): Value<T>;

  /**
   * Check if a given value could be pass to `shrink` without providing any context.
   *
   * In general, `canShrinkWithoutContext` is not designed to be called for each `shrink` but rather on very special cases.
   * Its usage must be restricted to `canShrinkWithoutContext` or in the rare* contexts of a `shrink` method being called without
   * any context. In this ill-formed case of `shrink`, `canShrinkWithoutContext` could be used or called if needed.
   *
   * *we fall in that case when fast-check is asked to shrink a value that has been provided manually by the user,
   *  in other words: a value not coming from a call to `generate` or a normal `shrink` with context.
   *
   * @param value - Value to be assessed
   * @returns `true` if and only if the value could have been generated by this instance
   *
   * @remarks Since 3.0.0
   */
  abstract canShrinkWithoutContext(value: unknown): value is T;

  /**
   * Shrink a value of type `T`, may rely on the context previously provided to shrink efficiently
   *
   * Must never be called with possibly invalid values and no context without ensuring that such call is legal
   * by calling `canShrinkWithoutContext` first on the value.
   *
   * @param value - The value to shrink
   * @param context - Its associated context (the one returned by generate) or `undefined` if no context but `canShrinkWithoutContext(value) === true`
   * @returns Stream of shrinks for value based on context (if provided)
   *
   * @remarks Since 3.0.0
   */
  abstract shrink(value: T, context: unknown | undefined): Stream<Value<T>>;

  /**
   * Create another arbitrary by filtering values against `predicate`
   *
   * All the values produced by the resulting arbitrary
   * satisfy `predicate(value) == true`
   *
   * Be aware that using filter may highly impact the time required to generate a valid entry
   *
   * @example
   * ```typescript
   * const integerGenerator: Arbitrary<number> = ...;
   * const evenIntegerGenerator: Arbitrary<number> = integerGenerator.filter(e => e % 2 === 0);
   * // new Arbitrary only keeps even values
   * ```
   *
   * @param refinement - Predicate, to test each produced element. Return true to keep the element, false otherwise
   * @returns New arbitrary filtered using predicate
   *
   * @remarks Since 1.23.0
   */
  filter<U extends T>(refinement: (t: T) => t is U): Arbitrary<U>;
  /**
   * Create another arbitrary by filtering values against `predicate`
   *
   * All the values produced by the resulting arbitrary
   * satisfy `predicate(value) == true`
   *
   * Be aware that using filter may highly impact the time required to generate a valid entry
   *
   * @example
   * ```typescript
   * const integerGenerator: Arbitrary<number> = ...;
   * const evenIntegerGenerator: Arbitrary<number> = integerGenerator.filter(e => e % 2 === 0);
   * // new Arbitrary only keeps even values
   * ```
   *
   * @param predicate - Predicate, to test each produced element. Return true to keep the element, false otherwise
   * @returns New arbitrary filtered using predicate
   *
   * @remarks Since 0.0.1
   */
  filter(predicate: (t: T) => boolean): Arbitrary<T>;
  filter<U extends T>(refinement: (t: T) => t is U): Arbitrary<U> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new FilterArbitrary(this, refinement);
  }

  /**
   * Create another arbitrary by mapping all produced values using the provided `mapper`
   * Values produced by the new arbitrary are the result of applying `mapper` value by value
   *
   * @example
   * ```typescript
   * const rgbChannels: Arbitrary<{r:number,g:number,b:number}> = ...;
   * const color: Arbitrary<string> = rgbChannels.map(ch => `#${(ch.r*65536 + ch.g*256 + ch.b).toString(16).padStart(6, '0')}`);
   * // transform an Arbitrary producing {r,g,b} integers into an Arbitrary of '#rrggbb'
   * ```
   *
   * @param mapper - Map function, to produce a new element based on an old one
   * @param unmapper - Optional unmap function, it will never be used except when shrinking user defined values. Must throw if value is not compatible (since 3.0.0)
   * @returns New arbitrary with mapped elements
   *
   * @remarks Since 0.0.1
   */
  map<U>(mapper: (t: T) => U, unmapper?: (possiblyU: unknown) => T): Arbitrary<U> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new MapArbitrary(this, mapper, unmapper);
  }

  /**
   * Create another arbitrary by mapping a value from a base Arbirary using the provided `fmapper`
   * Values produced by the new arbitrary are the result of the arbitrary generated by applying `fmapper` to a value
   * @example
   * ```typescript
   * const arrayAndLimitArbitrary = fc.nat().chain((c: number) => fc.tuple( fc.array(fc.nat(c)), fc.constant(c)));
   * ```
   *
   * @param chainer - Chain function, to produce a new Arbitrary using a value from another Arbitrary
   * @returns New arbitrary of new type
   *
   * @remarks Since 1.2.0
   */
  chain<U>(chainer: (t: T) => Arbitrary<U>): Arbitrary<U> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new ChainArbitrary(this, chainer);
  }

  /**
   * Create another Arbitrary with no shrink values
   *
   * @example
   * ```typescript
   * const dataGenerator: Arbitrary<string> = ...;
   * const unshrinkableDataGenerator: Arbitrary<string> = dataGenerator.noShrink();
   * // same values no shrink
   * ```
   *
   * @returns Create another arbitrary with no shrink values
   * @remarks Since 0.0.9
   */
  noShrink(): Arbitrary<T> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new NoShrinkArbitrary(this);
  }

  /**
   * Create another Arbitrary that cannot be biased
   *
   * @param freq - The biased version will be used one time over freq - if it exists
   * @remarks Since 1.1.0
   */
  noBias(): Arbitrary<T> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new NoBiasArbitrary(this);
  }
}

/** @internal */
type ChainArbitraryContext<T, U> = {
  originalBias: number | undefined;
  originalValue: T;
  originalContext: unknown;
  stoppedForOriginal: boolean;
  chainedArbitrary: Arbitrary<U>;
  chainedContext: unknown;
  clonedMrng: Random;
};

/** @internal */
class ChainArbitrary<T, U> extends Arbitrary<U> {
  constructor(
    readonly arb: Arbitrary<T>,
    readonly chainer: (t: T) => Arbitrary<U>,
  ) {
    super();
  }
  generate(mrng: Random, biasFactor: number | undefined): Value<U> {
    const clonedMrng = mrng.clone();
    const src = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value: unknown): value is U {
    // TODO Need unchainer
    return false;
  }
  shrink(value: U, context?: unknown): Stream<Value<U>> {
    if (this.isSafeContext(context)) {
      return (
        !context.stoppedForOriginal
          ? this.arb
              .shrink(context.originalValue, context.originalContext)
              .map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias))
          : Stream.nil<Value<U>>()
      ).join(
        context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
          // TODO - Move back to object spreading as soon as we bump support from es2017 to es2018+
          const newContext: ChainArbitraryContext<T, U> = safeObjectAssign(safeObjectAssign({}, context), {
            chainedContext: dst.context,
            stoppedForOriginal: true,
          });
          return new Value(dst.value_, newContext);
        }),
      );
    }
    // TODO Need unchainer
    return Stream.nil();
  }
  private valueChainer(
    v: Value<T>,
    generateMrng: Random,
    clonedMrng: Random,
    biasFactor: number | undefined,
  ): Value<U> {
    const chainedArbitrary = this.chainer(v.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context: ChainArbitraryContext<T, U> = {
      originalBias: biasFactor,
      originalValue: v.value_,
      originalContext: v.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng,
    };
    return new Value(dst.value_, context);
  }
  private isSafeContext(context: unknown): context is ChainArbitraryContext<T, U> {
    return (
      context != null &&
      typeof context === 'object' &&
      'originalBias' in (context as any) &&
      'originalValue' in (context as any) &&
      'originalContext' in (context as any) &&
      'stoppedForOriginal' in (context as any) &&
      'chainedArbitrary' in (context as any) &&
      'chainedContext' in (context as any) &&
      'clonedMrng' in (context as any)
    );
  }
}

/** @internal */
type MapArbitraryContext<T> = {
  originalValue: T;
  originalContext: unknown;
};

/** @internal */
class MapArbitrary<T, U> extends Arbitrary<U> {
  readonly bindValueMapper: (v: Value<T>) => Value<U>;
  constructor(
    readonly arb: Arbitrary<T>,
    readonly mapper: (t: T) => U,
    readonly unmapper?: (possiblyU: unknown) => T,
  ) {
    super();
    this.bindValueMapper = (v: Value<T>): Value<U> => this.valueMapper(v);
  }
  generate(mrng: Random, biasFactor: number | undefined): Value<U> {
    const g = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g);
  }
  canShrinkWithoutContext(value: unknown): value is U {
    if (this.unmapper !== undefined) {
      try {
        const unmapped = this.unmapper(value);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value: U, context?: unknown): Stream<Value<U>> {
    if (this.isSafeContext(context)) {
      return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== undefined) {
      const unmapped = this.unmapper(value);
      // As `shrink` should never be called without a valid context
      // except if `canShrinkWithoutContext` tells that the value was compatible with a shrink without any context
      // we can safely consider `this.arb.canShrinkWithoutContext(unmapped)` to be true at that point.
      return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  private mapperWithCloneIfNeeded(v: Value<T>): [U, T] {
    const sourceValue = v.value;
    const mappedValue = this.mapper(sourceValue);
    if (
      v.hasToBeCloned &&
      ((typeof mappedValue === 'object' && mappedValue !== null) || typeof mappedValue === 'function') &&
      Object.isExtensible(mappedValue) &&
      !hasCloneMethod(mappedValue)
    ) {
      // WARNING: In case the mapped value is not extensible it will not be extended
      Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
    }
    return [mappedValue, sourceValue];
  }
  private valueMapper(v: Value<T>): Value<U> {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
    const context: MapArbitraryContext<T> = { originalValue: sourceValue, originalContext: v.context };
    return new Value(mappedValue, context);
  }
  private isSafeContext(context: unknown): context is MapArbitraryContext<T> {
    return (
      context != null &&
      typeof context === 'object' &&
      'originalValue' in (context as any) &&
      'originalContext' in (context as any)
    );
  }
}

/** @internal */
class FilterArbitrary<T, U extends T> extends Arbitrary<U> {
  readonly bindRefinementOnValue: (v: Value<T>) => v is Value<U>;
  constructor(
    readonly arb: Arbitrary<T>,
    readonly refinement: (t: T) => t is U,
  ) {
    super();
    this.bindRefinementOnValue = (v: Value<T>): v is Value<U> => this.refinementOnValue(v);
  }
  generate(mrng: Random, biasFactor: number | undefined): Value<U> {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const g = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  canShrinkWithoutContext(value: unknown): value is U {
    return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
  }
  shrink(value: U, context?: unknown): Stream<Value<U>> {
    return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
  }
  private refinementOnValue(v: Value<T>): v is Value<U> {
    return this.refinement(v.value);
  }
}

/** @internal */
class NoShrinkArbitrary<T> extends Arbitrary<T> {
  constructor(readonly arb: Arbitrary<T>) {
    super();
  }
  generate(mrng: Random, biasFactor: number | undefined): Value<T> {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value: unknown): value is T {
    return this.arb.canShrinkWithoutContext(value);
  }
  shrink(_value: T, _context?: unknown): Stream<Value<T>> {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
}

/** @internal */
class NoBiasArbitrary<T> extends Arbitrary<T> {
  constructor(readonly arb: Arbitrary<T>) {
    super();
  }
  generate(mrng: Random, _biasFactor: number | undefined): Value<T> {
    return this.arb.generate(mrng, undefined);
  }
  canShrinkWithoutContext(value: unknown): value is T {
    return this.arb.canShrinkWithoutContext(value);
  }
  shrink(value: T, context?: unknown): Stream<Value<T>> {
    return this.arb.shrink(value, context);
  }
  noBias() {
    return this;
  }
}

/**
 * Ensure an instance is an instance of Arbitrary
 * @param instance - The instance to be checked
 * @internal
 */
export function isArbitrary(instance: unknown): instance is Arbitrary<unknown> {
  return (
    typeof instance === 'object' &&
    instance !== null &&
    'generate' in instance &&
    'shrink' in instance &&
    'canShrinkWithoutContext' in instance
  );
}

/**
 * Ensure an instance is an instance of Arbitrary
 * @param instance - The instance to be checked
 * @internal
 */
export function assertIsArbitrary(instance: unknown): asserts instance is Arbitrary<unknown> {
  if (!isArbitrary(instance)) {
    throw new Error('Unexpected value received: not an instance of Arbitrary');
  }
}

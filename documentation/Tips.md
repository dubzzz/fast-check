# [:house:](../README.md) Tips

Simple tips to unlock all the power of fast-check with only few changes.

## Filter invalid combinations using pre-conditions

Filtering invalid combinations of generated entries can be done in two ways in fast-check:
- at arbitrary level using `.filter(...)`
- at property level using `fc.pre(expectedToBeTrue)`

This part describes the usage of `fc.pre(...)`. More details on `.filter(...)` in [Advanced Arbitraries](./AdvancedArbitraries.md).

`fc.pre(...)` can be used anywhere within check functions. For instance, you might write:

```js
fc.assert(
  fc.property(
    fc.nat(), fc.nat(),
    (a, b) => {
      // runs not having a < b will be disgarded
      fc.pre(a < b);
      // ... your code
      // ... and possibly other preconditions using fc.pre(...)
    }
  )
)
```

Whenever it encounters a failing precondition, the framework generates another value and forgets about this run - *neither failed nor succeeded*.

## Opt for verbose failures

By default, the failures reported by `fast-check` feature most relevant data:
- seed
- path towards the minimal counterexample
- number of tries before the first failure
- depth of the shrink
- minimal counterexample

`fast-check` comes with a verbose mode, which can help users while trying to dig into a failure.

For instance, let's suppose the folowwing property failed:
```js
fc.assert(
    fc.property(
        fc.string(), fc.string(), fc.string(),
        (a,b,c) => contains(a+b+c, b)));
```

The output will look something like:
```
Error: Property failed after 1 tests (seed: 1527423434693, path: 0:0:0): ["","",""]
Shrunk 1 time(s)
Got error: Property failed by returning false

Hint: Enable verbose mode in order to have the list of all failing values encountered during the run
```

In order to enable the `verbose` mode, we just need to give a second parameter to `fc.assert` as follow:
```js
fc.assert(
    fc.property(
        fc.string(), fc.string(), fc.string(),
        (a,b,c) => contains(a+b+c, b)),
    {verbose: true});
```

Verbose logs give more details on the error as they will contain all the counterexamples encountered while shrinking the inputs. The example above results in:
```
Error: Property failed after 1 tests (seed: 1527423434693, path: 0:0:0): ["","",""]
Shrunk 2 time(s)
Got error: Property failed by returning false

Encountered failures were:
- ["","JeXPqIQ6",">q"]
- ["","",">q"]
- ["","",""]
```

With that output, we notice that our `contains` implementation seems to fail when the `pattern` we are looking for is the beginning of the string we are looking in.

## Preview generated values

Before writing down your test, it might be great to confirm that the arbitrary you will be using produce the values you want.

This can be done very easily by using either `fc.sample` or `fc.statistics`.

The following code constructs an array containing the first 10 values that would have been generated by the arbitrary `fc.anything()` if used inside a `fc.assert` or `fc.check`:

```typescript
fc.sample(
    fc.anything(), // arbitrary or property to extract the values from
    10             // number of values to extract
);
```

In some cases, having a sample is not enough and we want more insights about the generated data.
For instance, I might be interested by the share of even numbers generated by `fc.nat()`.
For that purpose I can use `fc.statistics` as follow:

```typescript
fc.statistics(
    fc.nat(),    // arbitrary or property to extract the values from
    n => n % 2 === 0 ? 'Even number' : 'Odd number', // classifier
    10000        // number of values to extract
);
// Possible output (console.log):
// Odd number...50.30%
// Even number..49.70%
```

## Replay after failure

`fast-check` comes with a must have feature: replay a failing case immediately given its seed and path (seed only to replay all).

Whenever `fc.assert` encounters a failure, it displays an error log featuring both the seed and the path to replay it. For instance, in the output below the seed is 1525890375951 and the path 0:0.

```
Error: Property failed after 1 tests (seed: 1525890375951, path: 0:0): [0]
Shrunk 1 time(s)
Got error: Property failed by returning false
```

In order to replay the failure on the counterexample - `[0]`, you have to change your code as follow:

```typescript
// Original code
fc.assert(
  fc.property(
    fc.nat(),
    checkEverythingIsOk
  )
);

// Replay code: straight to the minimal counterexample
fc.assert(
  fc.property(
    fc.nat(),
    checkEverythingIsOk
  ),
  {
    seed: 1525890375951,
    path: "0:0"
  }
);
```

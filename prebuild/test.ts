import { commas, iota, joiner, txCommas } from './helpers';
import { predicateFor } from './property';

const testPredicateFor = (num: number) => `(${predicateFor(num, true)}) | (${predicateFor(num, false)})`;

const signatureFor = (num: number): string => {
  return `
        /**
         * Instanciate a new
         * @param definition Test definition function of the test framework - eg.: it in Mocha
         * @param label Label of the property
         * ${joiner(num, v => `@param arb${v} Generate the parameter at position #${v + 1} of predicate`, '\n* ')}
         * ${joiner(num, v => `@param predicate.t${v} Value generated by arb${v}`, '\n* ')}
         * @param predicate Assess the success of the property. Would be considered falsy if its throws or if its output evaluates to false
         */
        function test<TestDefinitionOutput,${txCommas(num)}>(
            definition: TestDefinition<TestDefinitionOutput>,
            label: string,
            ${commas(num, v => `arb${v}:Arbitrary<T${v}>`)},
            predicate: ${testPredicateFor(num)}
        ): void;`;
};
const finalSignatureFor = (num: number): string => {
  return `
        function test<TestDefinitionOutput,${txCommas(num)}>(
            definition: TestDefinition<TestDefinitionOutput>,
            label: string,
            ${commas(num, v => `arb${v}?: Arbitrary<T${v}> | (${testPredicateFor(v)})`)},
            arb${num}?: ${testPredicateFor(num)}
        ) {`;
};
const ifFor = (num: number): string => {
  return `
        if (arb${num}) {
            const seed = Date.now();
            const p = arb${num} as ${testPredicateFor(num)};
            const pp = async (${commas(num, v => `v${v}:T${v}`)}) => await p(${commas(num, v => `v${v}`)});
            definition(label + " (seed: " + seed + ")", async () => {
                await assert(
                    asyncProperty(${commas(num, v => `arb${v} as Arbitrary<T${v}>`)}, pp),
                    {seed: seed});
            });
            return;
        }`;
};

const generateTest = (num: number): string => {
  const blocks = [
    // imports
    `import Arbitrary from '../arbitrary/definition/Arbitrary';`,
    `import { asyncProperty } from '../property/AsyncProperty';`,
    `import { assert } from '../runner/Runner';`,
    `import { TestDefinition } from './TestDefinition';`,
    // declare all signatures
    ...iota(num).map(id => signatureFor(id + 1)),
    // start declare function
    finalSignatureFor(num + 1),
    // cascade ifs
    ...iota(num)
      .reverse()
      .map(id => ifFor(id + 1)),
    // end declare function
    `}`,
    // export
    `export { test };`
  ];

  return blocks.join('\n');
};

export { generateTest };
